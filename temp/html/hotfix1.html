<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>热修复与插件化专题一</title>

</head>
<body>

<h1 id="toc_0" style="text-align: center">热修复与插件化专题一：dex&amp;虚拟机&amp;ClassLoader</h1>

<p style="text-align: right">
    why <br>
    <span style="font-size: 12px; color: #666;">2017-09-12 24:05:12</span>
</p>

<h2 id="toc_1">前期预备知识</h2>

<h3 id="toc_2">dex/class</h3>

<ol>
    <li><p>class文件结构解析</p>

        <ul>
            <li><p>什么是class文件？</p>

                <blockquote>
                    <p>能够被jvm识别，加载并执行的文件格式 </p>
                </blockquote></li>
            <li><p>如何生成一个class文件</p>

                <ul>
                    <li class="task-list-item"><input type="checkbox" checked> 通过IDE自动帮我们build
                    </li>
                    <li class="task-list-item"><input type="checkbox" checked> 手动通过javac 去生成class文件<br/>
                        PS: 如何制定jdk版本生成字节码文件呢？—&gt;javac -target 1.6 -source 1.6 HelloWorld.java
                    </li>
                    <li class="task-list-item"><input type="checkbox" checked> 通过java命令去执行class文件<br>
                        <strong>java com.example.hostfit.Test</strong>  ps: 执行时根据全类名来执行的<br>
                    </li>
                </ul></li>
            <li><p>class文件的作用<br>
                记录类文件的<strong>所有</strong>信息（记录了this super 等关键字）</p></li>
            <li><p>class文件结构及格式（宏观）<br>
                <a href="http://o72lx27yo.bkt.clouddn.com/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png"><img src="http://o72lx27yo.bkt.clouddn.com/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="class文件结构" width=400px height=200px></a></p>

                <ul>
                    <li>一种八位字节的二进制流文件</li>
                    <li>各个数据按照顺序紧密排列，无间隙</li>
                    <li>每个类或接口都单独占一个class文件</li>
                </ul></li>
            <li><p>class文件弊端</p>

                <ul>
                    <li>内存占用大，不适合移动端</li>
                    <li>堆栈加载模式，加载速度慢</li>
                    <li>文件IO操作多，类查找慢</li>
                </ul></li>
        </ul></li>
    <li><p>dex文件结构解析</p>

        <ul>
            <li><p>什么是dex文件</p>

                <blockquote>
                    <p>被DVM虚拟机识别，加载并执行的文件格式</p>
                </blockquote></li>
            <li><p>如何生成dex文件</p>

                <ul>
                    <li class="task-list-item"><input type="checkbox" checked> 通过IDE自动帮我们build生成
                    </li>
                    <li class="task-list-item"><input type="checkbox" checked> 手动通过dx命令去生成dex文件<br/>

                        <ul>
                            <li><code>javac -target 1.6 -source 1.6 Test.java</code> 生成class文件。ps:指定1.6 版本为了保证兼容</li>
                            <li> <code>dx --dex --output=Test.dex com/example/hostfit/Test.class</code> ps: 是根据全类名来找的</li>
                        </ul>
                    </li>
                    <li class="task-list-item"><input type="checkbox" checked> 手动运行dex文件在手机上

                        <ul>
                            <li>将dex文件push 到手机存储卡中 <code>adb push Test.dex &#39;手机路径(例如：/sdcard)&#39;</code></li>
                            <li><code>dalvikvm -cp Test.dex  com.example.hostfit.Test</code> ps： 注意全类名</li>
                        </ul>
                    </li>
                </ul></li>
            <li><p>dex文件的作用</p>

                <blockquote>
                    <p>记录<strong>整个工程</strong>中所有类文件的信息。</p>
                </blockquote></li>
            <li><p>dex文件结构、格式的详解<br>
                <a href="http://o72lx27yo.bkt.clouddn.com/dex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png"><img src="http://o72lx27yo.bkt.clouddn.com/dex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="dex文件结构" width=400px height=200px></a></p>

                <ul>
                    <li>一种八位字节的二进制流文件</li>
                    <li>各个数据按照顺序紧密排列，无间隙</li>
                    <li>整个应用中所有的java源文件都放在一个dex文件中 ps： 不考虑android 官方提供的multidex</li>
                </ul></li>
        </ul></li>
    <li><p>class 与 dex 文件对比 <br>
        <a href="http://o72lx27yo.bkt.clouddn.com/class%20&&%20dex%E5%BC%82%E5%90%8C.png"><img src="http://o72lx27yo.bkt.clouddn.com/class%20&&%20dex%E5%BC%82%E5%90%8C.png" alt="class 与 dex异同" width=450px height=250px></a></p>

        <ul>
            <li>本质上他们都是一样的，dex文件从class文件演变而来</li>
            <li>class文件存在许多冗余信息（一个类就有一个常量池），而dex文件会去除冗余，并进行整合 </li>
        </ul></li>
</ol>

<h3 id="toc_3">jvm/dvm/art 三种虚拟机</h3>

<ol>
    <li><p>java 虚拟机结构解析</p>

        <ul>
            <li>jvm整体结构</li>
        </ul>

        <p><a href="http://o72lx27yo.bkt.clouddn.com/jvm%E7%BB%93%E6%9E%84.png"><img src="http://o72lx27yo.bkt.clouddn.com/jvm%E7%BB%93%E6%9E%84.png" alt="jvm 结构" width=450px height=250px></a></p>

        <ul>
            <li><p>java代码的编译和执行过程</p>

                <ul>
                    <li><p>代码编译过程<br>
                        <a href="http://o72lx27yo.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.png"><img src="http://o72lx27yo.bkt.clouddn.com/%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.png" alt="编译流程" width=450px height=250px></a></p></li>
                    <li><p>执行过程<br>
                        <a href="http://o72lx27yo.bkt.clouddn.com/%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png"><img src="http://o72lx27yo.bkt.clouddn.com/%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="加载流程" width=450px height=250px></a></p>

                        <ol>
                            <li>Loadding :类的信息从文件中获取并且载入到JVM内存中</li>
                            <li>Verrifying: 检查读入的结构是否符合JVM规范的描述</li>
                            <li>Preparing: 分配一个结构用来存储类信息</li>
                            <li>Resolving: 把这个类的常量池所有的符号引用改变成直接引用</li>
                            <li>Initializing: 执行静态初始化程序，把静态变量初始化指定的值</li>
                        </ol></li>
                </ul></li>
            <li><p>Java 内存管理</p>

                <ul>
                    <li><p>Java 栈区</p>

                        <blockquote>
                            <p>用来存放Java方法执行的所有数据 ps： method call-&gt; a -&gt; b - c；栈区由栈帧组成，一个栈帧代表一个方法的执行。</p>
                        </blockquote>

                        <p>那什么是<strong>栈帧</strong>呢？每一个方法从调用到执行完成就对应一个栈帧在虚拟机中入栈到出栈。每一个栈帧包括局部变量表、栈操作数、动态链接、方法出口。例如（StackOverFlow异常）</p>

                        <p>本地方法栈：和Java方法栈如出一辙，只不过本地方法栈是专门未Native方法服务的  </p></li>
                    <li><p>方法区</p>

                        <blockquote>
                            <p>存储被虚拟机加载的类信息，常量，静态变量，即时编译器后等数据，用于占据内存的</p>
                        </blockquote></li>
                    <li><p>Java堆</p>

                        <blockquote>
                            <p>所有通过New创建的对象的内存都在堆中分配，是虚拟机中最大的一块内存，是GC 要回收的部分 </p>
                        </blockquote>

                        <p><a href="http://o72lx27yo.bkt.clouddn.com/%E5%A0%86%E5%8C%BA%E5%86%85%E5%AD%98.png"><img src="http://o72lx27yo.bkt.clouddn.com/%E5%A0%86%E5%8C%BA%E5%86%85%E5%AD%98.png" alt="Java 堆区内存" width=450px height=250px></a></p>

                        <ol>
                            <li>Young Generation : 刚刚New出来的对象 </li>
                            <li>Old Generation: 当Young Generation 中内存空间不足的时候，就会将Young Generation 中的对象按照一定的算法、规则等存放到Old Generation, 这样 Young Generation 就可以继续分配内存，当两者都没有剩余的空间的时候，就会发生OOM异常，垃圾回收器主要针对这两块内存区域，</li>
                            <li>Permanent Generation: <strong>Java8 已经移除</strong></li>
                        </ol>

                        <p>特点：Young Old Generation 可以动态分配，当我们的服务器处理的是及时通讯相关服务，就可以将Young Generation内存区域调整大一些；当我们不需要频繁去创建对象的时候，可以将Young Generation 内存区域调整小一些，这样达到内存对象常驻的效果</p></li>
                </ul></li>
            <li><p>Java 内存回收机制</p>

                <ol>
                    <li><p>垃圾回收算法</p>

                        <ul>
                            <li><p>引用计数算法</p>

                                <p>缺点：互相循坏引用 ，两个对象不可达，但是GC依然不会回收</p></li>
                            <li><p>可达性算法</p>

                                <p><a href="http://o72lx27yo.bkt.clouddn.com/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%951.png"><img src="http://o72lx27yo.bkt.clouddn.com/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%951.png" alt="Java 堆区内存" width=450px height=250px></a>  </p></li>
                        </ul></li>
                    <li><p>引用类型</p>

                        <blockquote>
                            <p>强引用、弱引用、软引用、虚引用</p>
                        </blockquote></li>
                    <li><p>如何回收垃圾</p>

                        <ul>
                            <li><p>标记-清除算法   </p>

                                <p><a href="http://o72lx27yo.bkt.clouddn.com/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png"><img src="http://o72lx27yo.bkt.clouddn.com/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="Java 堆区内存" width=450px height=250px></a><br>
                                    优点： 内存块不需要进行对象移动，存活对象比较多的时候，高效；<br>
                                    缺点： 容易造成内存碎片，不利于后续对象的分配</p></li>
                            <li><p>复制算法</p>

                                <p><a href="http://o72lx27yo.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"><img src="http://o72lx27yo.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="Java 堆区内存" width=450px height=250px></a><br><br>
                                    优点：存活的对象比较少，比较高效<br>
                                    缺点：成本需要一块内存作为交换空间</p></li>
                            <li><p>标记-整理算法</p>

                                <p><a href="http://o72lx27yo.bkt.clouddn.com/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png"><img src="http://o72lx27yo.bkt.clouddn.com/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="Java 堆区内存" width=450px height=250px></a><br>
                                    优点： 解决内存碎片问题<br>
                                    缺点： 成本较高一点  </p></li>
                        </ul></li>
                    <li><p>触发回收机制</p>

                        <ul>
                            <li class="task-list-item"><input type="checkbox" checked> Java虚拟机无法再为新的对象分配内存空间
                            </li>
                            <li class="task-list-item"><input type="checkbox"> 手动调用System.gc() <strong>强烈不推荐</strong>
                            </li>
                            <li class="task-list-item"><input type="checkbox" checked> 低优先级的GC线程，被Jvm 启动了，执行GC<br>
                            </li>
                        </ul></li>
                </ol></li>
        </ul></li>
    <li><p>Dalvik 与 jvm的不同</p>

        <ul>
            <li>执行的文件不同 一个是dex 一个是class文件</li>
            <li>类加载的系统（ClassLoader）与JVM的区别比较大</li>
            <li>jvm 只能同时存在一个，DVM可以同时存在多个</li>
            <li>DVM 是基于寄存器的（运行更快），JVM 是基于栈的</li>
        </ul></li>
    <li><p>ART比Dalvik有哪些优势 </p>

        <ul>
            <li>DVM 使用的是JIT来将字节码转换成机器码（每次运行），效率低</li>
            <li>ART 是采用AOT的预编译技术（安装的时候就将字节码转换成机器码存储于介质中，不需要每次进行转换），执行速度更快</li>
            <li>ART 会占用更多的应用安装时间和存储空间（以空间换时间）</li>
        </ul></li>
</ol>

<h3 id="toc_4">class loader(Java Android)</h3>

<p>类是如何加载到虚拟机的？</p>

<ol>
    <li><p>Java 中的ClassLoader回顾</p>

        <p><a href="http://o72lx27yo.bkt.clouddn.com/Java_ClassLoader.png"><img src="http://o72lx27yo.bkt.clouddn.com/Java_ClassLoader.png" alt="Java ClassLoader" width=450px height=250px></a><br>
            具体回顾 -&gt; java代码的编译和执行过程</p></li>
    <li><p>Android中ClassLoader 作用详解</p>

        <ul>
            <li><p>Android ClassLoader的种类</p>

                <ul>
                    <li><p>BootsClassLoader</p>

                        <p>用来加载Android framework层的一些dex文件</p></li>
                    <li><p>PathClassLoader</p>

                        <p>用来加载已经安装到系统中的apk文件中的dex文件</p></li>
                    <li><p>DexClassLoader</p>

                        <p>用来加载指定目录中dex文件</p></li>
                    <li><p>BaseDexClassLoader</p>

                        <p>是PathClassLoader DexClassLoader 的父类</p></li>
                </ul>

                <p><strong>一个App至少需要BootClassLoader 和PathClassLoader</strong>   </p></li>
            <li><p>Android ClassLoader 的特点</p>

                <ul>
                    <li><p>双亲代理模型特点</p>

                        <p>当前的classLoader去加载此类，如果当前此类已经被ClassLoader加载过就不再加载，直接返回；<br>
                            如果未加载，便会查询它的Parents 是否加载过此类，如果加载过 就返回parents加载过的字节码文件；<br>
                            如果整个继承线的都没有加载过此类，便会子类真正的加载，提高类加载效率。这样就会带来以下两个作用</p></li>
                    <li><p>类加载的共享功能<br>
                        一些FrameWork层级的类 ，一旦被顶层的classLoader加载过，那么它就会缓存到内存里面，以后任何地方用到，就不用重新加载了</p></li>
                    <li><p>类加载的隔离功能<br>
                        不同继承路线上的ClassLoader 加载的类不是同一个类，避免开发者自己写一代码伪造成系统的类库来访问我们系统可见成员变量。例如：系统层级的类一般初始化的时候就会加载，比如java.lang.String, 应用程序启动之前就会被系统加载，如果在一个app里面写一个自定String 替换掉java.lang.String 会造成严重的安全问题。判断是否是同一个类判断，除了className packageName 另外还需要是同一个ClassLoader加载的。</p></li>
                </ul></li>
            <li><p>ClassLoader 源码 （加载流程）</p>

                <p><a href="http://o72lx27yo.bkt.clouddn.com/classLoader%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png"><img src="http://o72lx27yo.bkt.clouddn.com/classLoader%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="Java ClassLoader" width=450px height=250px></a><br>
                    ClassLoader loadClass 首先判断被自己或者双亲加载过，如果未加载过，调用BaseDexClassLoader 的findClass，调用DexPathList findClass ,并且完成将dex文件转换成DexFile ,转换成Elements, 遍历数据，调用DexFile loadClassBinaryName - &gt; native</p></li>
        </ul></li>
    <li><p>Android 中动态加载要点？</p>

        <ul>
            <li>有许多组件（Activity）类需要注册才能使用</li>
            <li>资源动态加载复杂（注册、兼容性）<br></li>
            <li>程序运行的时候需要一个上下文环境<br></li>
        </ul></li>
</ol>

<hr>

<h2 id="toc_5">热修复</h2>

<p>稍等片刻，美味敬请期待~~~</p>

</body>
</html>